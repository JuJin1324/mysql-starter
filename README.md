# mysql-starter

## 설치
### version 선택 팁
> 기존 솔루션이 특정 버전만 지원하는 경우와 같은 제약 사항이 존재하지 않는다면 가능한 한 최신 버전을 설치하는 것이 좋다.  
> 기존 버전에서 새로운 메이저 버전(5.5, 5.6, 5.7, 8.0)으로 업그레이드하는 경우라면 최소 패치 버전이 15~20번 이상 릴리즈된 버전을 선택하는 것이
> 안정적인 서비스에 도움이 될 것이다. 즉 MySQL 8.0 버전 선택시 8.0.15 이상의 버전을 선택하는 것이 안정적인 서비스에 도움이 된다.  

### macOS
> mysql 5.x  
> `brew install mysql@5.x`  
>
> mysql 8.0  
> `brew install mysql`  
> 
> mysql service 시작  
> `brew services start mysql`  
> 
> version 확인  
> `mysql --version`

### Ubuntu
> mysql 8.x  
> `sudo apt update; sudo apt install -y mysql-server`
>
> mysql service 시작  
> `service mysql start`  
> 
> version 확인  
> `mysql --version`

### docker
> mysql 5.7  
> `docker run -d -p 3306:3306 --name starter-mysql mysql:5.7`
> 
> mysql 8.0  
> `docker run -d -p 3306:3306 --name starter-mysql mysql:8.0`
>
> version 확인  
> `docker exec -it starter-mysql mysql --version`

---

## 서버 연결
### mycli
> mycli 는 mysql client 로 자동 완성 등의 추가 기능을 제공하는 클라이언트이다.  
> 
> 설치 - macOS  
> `brew install mycli`  
> 
> 설치 - Ubuntu  
> `sudo apt update; sudo apt install -y mycli`  

### 연결
> `mycli -u <username> -p --host=<host IP address> --port=<port>`  
> host 를 localhost 로 명시하는 것과 127.0.0.1 로 명시하는 것은 각각 의미가 다르다. --host=localhost 옵션을 사용하면 MySQL 클라이언트 프로그램은 항상
> 소켓 파일을 통해 MySQL 서버에 접속하게 되는데, 이는 'Unix domain socket' 을 이용하는 방식으로 TCP/IP 를 통한 통신이 아니라 유닉스 프로세스 간 통신(IPC)의 일종이다.  
> 하지만 127.0.0.1 을 사용하는 경우에는 자기 서버를 가리키는 루프백(loopback) IP 이기는 하지만 TCP/IP 통신 방식을 사용하는 것이다.  
> 그래서 docker 사용 시 host 를 localhost 로 사용하면 connection refused 가 발생하여 연결이 되지 않으며 127.0.0.1 을 사용하거나 내부 IP 주소를 명시하여야 한다.      

---

## MySQL 서버 업그레이드
### 방법
> MySQL 서버를 업그레이드 하는 방법은 2가지 방법이 있다.  
> 1.인플레이스 업그레이드(In-Place Upgrade): MySQL 서버의 데이터 파일을 그대로 두고 업그레이드  
> 2.논리적 업그레이드(Logical Upgrade): mysqldump 도구 등을 이용해 MySQL 서버의 데이터를 SQL 문장이나 텍스트 파일로 덤프한 후, 새로 업그레이드된 버전의 
> MySQL 서버에서 덤프된 데이터를 적재.

### 인플레이스 업그레이드 제약 사항
> 동일 메이저 버전에서 마이너 버전 업데이트는 대부분 데이터 파일의 변경 없이 진행되며, 여러 버전을 건너뛰어서 업데이트하는 것도 허용된다. 예를 들어 MySQL 8.0.16 에서
> 8.0.21 버전으로 업데이트 시 MySQL 서버 프로그램만 재설치하면 된다.  
> 
> 하지만 메이저 버전 간 업그레이드는 대부분 크고 작은 데이터 파일의 변경이 필요하기 때문에 반드시 직전 버전에서만 업그레이드가 허용된다. 예를 들어 MySQL 5.5 버전에서
> 5.6 버전으로는 업그레이드가 가능하지만 5.5 버전에서 5.7 버전이나 8.0 버전으로 업그레이드는 지원하지 않는다.  
> 그래서 만약 두 단계 이상을 한 번에 업그레이드해야 한다면 논리적 업그레이드를 하는 것이 더 나은 방법일 수 있다.  
> 인플레이스 업그레이드 시 한가지 더 주의할 점은 메이저 버전 업그레이드가 특정 마이너 버전에서만 가능한 경우도 있다는 것이다. 메이저 버전 업데이트 시에는 MySQL 서버의 메뉴얼을
> 정독한 후 진행할 것을 권장한다.

---

## 시스템 설정
### 설정 파일
> MySQL 은 설정파일로 my.cnf 파일을 사용한다.
> 하나의 my.cnf 파일 안에 여러 개의 설정 그룹을 담을 수 있으며 대체로 실행 프로그램 이름을 그룹명으로 사용한다.
> 예를 들어 mysqldump 프로그램은 [mysqldump] 설정 그룹을, mysqld 프로그램은 설정 그룹의 이름이 [mysqld] 인 영역을 참조한다.
> 각 프로그램 마다 다른 cnf 파일을 사용할 수 있으며 my.cnf 파일을 mysqld 프로그램에서만 사용한다면 [mysqld] 그룹만 설정파일에 기술하면 된다.  
> mysqldump, mysql 및 mysqld 등의 프로그램에서 모두 하나의 my.cnf 파일을 사용한다면 각 프로그램의 그룹에 설정 값들을 기술하면 된다.
> [mysqld] 와 [mysql] 에 각각 port 설정 값이 존재할 수 있으며 설정 파일 하나에 port 설정이 2개 이상이지만 각 그룹에만 적용이 된다.  

### 시스템 변수
> MySQL 서버는 설정 파일의 내용을 읽어 메모리나 작동 방식을 초기화하고, 접속된 사용자를 제어하기 위해 이러한 값을 별도로 저장해 둔다. 이 값들을 시스템 변수라고 한다.  
> 시스템 변수는 MySQL 서버에 접속해 `SHOW VARIABLES`(세션 변수) 또는 `SHOW GLOBAL VARIABLES`(글로벌 변수) 명령을 통해서 확인할 수 있다.  
> 
> 글로벌 변수  
> 하나의 MySQL 서버 인스턴스에서 전체적으로 영향을 미치는 시스템 변수를 의미하며, 주로 MySQL 서버 자체에 관련된 설정일 때가 많다.  
> innodb_buffer_pool_size 가 대표적인 예이다.  
> 
> 세션 변수  
> 클라이언트가 서버에 접속할 때 기본적으로 부여하는 옵션의 기본값을 제어하는데 사용된다. 여기서 기본값은 글로벌 변수이며 클라이언트의 필요에 따라
> 개별 커넥션 단위로 다른 값으로 변경할 수 있는 것이 세션 변수이다. autocommit 이 대표적인 예이다.  

### SET PERSIST
> 동적 변수는 MySQL 서버가 동작 중인 상태에서도 변경이 가능한 시스템 변수이다.  
> 동적 변수 변경 시 `SET GLOBAL <동적 변수명>=<값>` 명령을 사용하는데 이는 서버가 구동 중인 상태에서만 적용되며 서버가 중지된 후 재구동되면
> my.cnf 에 설정된 값으로 다시 변경된다.
> 
> 하지만 `SET PERSIST <동적 변수명>=<값>` 명령을 사용하면 해당 값을 mysqld-auto.cnf 파일에 저장하여 서버가 재구동될 시에도 서버에서 구동 시
> my.cnf 및 mysqld-auto.cnf 파일을 같이 읽어 서버에 반영하기 때문에 동적 변수 값을 영구 저장할 수 있다.  
> SET PERSIST 명령은 세션 변수에는 적용되지 않는다.  
> SET PERSIST 명령은 현재 구동 중인 시스템 변수의 변경 및 mysqld-auto.cnf 파일에도 변경된 시스템 변수를 저장한다.    
> SET PERSIST_ONLY 명령은 현재 구동 중인 시스템 변수는 변경하지 않고 mysqld-auto.cnf 파일에만 시스템 변수를 변경하여 저장한다.  
> 참고로 mysqld-auto.cnf 파일의 내부 구조는 JSON 포멧으로 되어있다.  

### 확인
> 시스템 변수 필터링해서 확인  
> ```sql
> show variables where variable_name in
>   ('max_connections', 'innodb_sort_buffer_size', 'innodb_redo_log_capacity', 'innodb_log_buffer_size',
>   'innodb_buffer_pool_size', 'innodb_buffer_pool_instances', 'innodb_page_cleaners', 'innodb_io_capacity',
>   'innodb_io_capacity_max', 'autocommit', 'default_storage_engine', 'lower_case_table_names',
>   'innodb_table_locks', 'innodb_deadlock_detect', 'innodb_lock_wait_timeout',
>   'transaction_isolation', 'collation_server', 'character_set_server', 'character_set_filesystem',
>   'system_time_zone');
> ```

---

## 사용자 및 권한
### 사용자 식별
> MySQL 은 사용자의 접속 지점(호스트 명이나 도메인 또는 IP 주소)도 계정의 일부가 된다.  
> 'jujin'@'localhost' 와 'jujin'@'192.168.0.12' 는 다른 계정이다.  
> 모든 외부 컴퓨터에서 접속이 가능한 계정을 생성하기 위해서는 접속 지점에 % 를 명시하여 다음과 같은 형태로 계정을 생성한다: 'jujin'@'%'  
> 만약 계정이 다음 2개가 존재하고  
> 'jujin'@'localhost', 'jujin'@'%'  
> localhost 에서 jujin 계정을 로그인을 시도하면 접속 지점의 범위가 작은 것을 항상 먼저 선택함으로 'jujin'@'localhost' 가 선택되며 
> 두 계정의 패스워드가 다른 경우에 localhost 에서 'jujin'@'%' 의 패스워드를 통해서 접속하려하면 '비밀번호가 일치하지 않는다'라는 오류를 내며
> 접속을 거부한다.

### 사용자 계정 관리
> MySQL 8.0 부터 계정은 `시스템 계정(System account)` 과 `일반 계정(Regular account)` 로 구분된다.  
> 
> **시스템 계정**  
> 시스템 계정은 SYSTEM_USER 권한을 가진 계정이며 데이터베이스 서버 관리자를 위한 계정이다.  
> 시스템 계정은 일반 계정을 관리(생성, 삭제, 변경)할 수 있지만 일반 계정은 시스템 계정을 관리할 수 없다.    
> 계정 관리(계정 생성 및 삭제, 그리고 계정의 권한 부여 및 제거)가 가능하다.  
> 다른 세션(Connection) 및 현재 세션에서 실행 중인 쿼리를 강제 종료가 가능하다.  
>
> **Account lock**
> 계정 생성 시 또는 ALTER USER 명령을 사용해 계정을 사용하지 못하게 잠글지 여부를 결정한다.  
> `ACCOUNT LOCK`: 계정을 사용하지 못하게 잠금  
> `ACCOUNT UNLOCK`: 잠긴 계정을 다시 사용 가능 상태로 잠금 해제  
> 
> **Dual Password**  
> 애플리케이션 서버에서 공용으로 DB 서버를 사용하기 때문에 애플리케이션에서 사용하는 계정 정보는 패스워드 변경이 힘들었다. 
> 해당 계정의 패스워드를 변경하기 위해서는 계정을 사용하는 애플리케이션들을 모두 중단해야하기 때문이다.  
> 그래서 MySQL 8.0 부터 나온 기능이 Dual Password 기능으로 하나의 계정에 대해 2개의 패스워드를 가지게 할 수 있다.  
> 2개의 비밀번호는 primary 와 secondary 로 구분된다. 최근에 설정한 비밀번호가 primary 이며 old 비밀번호가 secondary 이다.  
> dual password 를 사용하려면 패스워드 변경 구문의 마지막에 `RETAIN CURRENT PASSWORD` 옵션을 추가하면 된다.  
> ```sql
> ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password' RETAIN CURRENT PASSWORD;
> ```
> primary 패스워드와 secondary 패스워드 중 아무거나 패스워드를 입력하면 계정에 로그인이 되기 때문에 이전의 패스워드를 사용하는 애플리케이션들에
> 영향이 가지 않는다. 하지만 결국 패스워드 변경 주기에 맞춰서 패스워드를 변경해야하는 상황이 또 온다.  
> 계정 당 패스워드는 최대 2개씩만 가질 수 있음으로 `RETAIN CURRENT PASSWORD` 옵션을 통해서 패스워드를 변경하게 되면 primary 뿐만 아니라
> secondary 패스워드도 같이 바뀌게 된다.  
> 그럼으로 secondary 패스워드는 임시 패스워드라고 생각하고 변경 후 최대한 빨리 애플리케이션들의 커넥션 정보를 primary 패스워드로 변경 후 배포하고
> secondary 패스워드는 보안을 위해서도 제거하는 것이 좋다. 다음은 secondary 패스워드를 제거하는 명령이다.  
> ```sql
> ALTER USER 'root'@'localhost' DISCARD OLD PASSWORD;
> ```
> 
> **계정 쿼리 예시**  
> 1.내부 접근만 허용하는 계정 생성: `CREATE USER '<username>'@'localhost' identified by '<password>';`  
> 1-1.외부 접근을 허용하는 계정 생성: `CREATE USER '<username>'@'%' identified by '<password>';`  
>
> 2.계정 조회: `select user, host from mysql.user;`   
> 
> 3.계정 패스워드 변경(dual password 사용): `ALTER USER '<username>'@'<host>' IDENTIFIED BY '<new password>' RETAIN CURRENT PASSWORD;`  
> 
> 4.계정 삭제: `DROP USER '<username>'@'<host>';`

### 권한(Privilege)
> 권한은 글로벌 권한과 객체 권한으로 구분된다.  
> 
> **글로벌 권한**  
> 글로벌 권한은 계정 및 시스템에 관한 권한이며, 객체 권한은 주로 데이터베이스 및 테이블에 관한 권한이다.  
> 글로벌 권한은 특정 DB 나 테이블에 부여될 수 없기 때문에 글로벌 권한을 부여할 때 GRANT 명령의 ON 절에는 항상 `*.*` 를 사용한다.  
> 
> **권한 부여 명령어**  
> `GRANT <권한> ON <DB 명>.<Table 명> TO '<username>'@'<host>';`  
>
> **DB 권한**  
> DB 권한은 특정 DB 에 대해서만 권한을 부여하거나 서버에 존재하는 모든 DB 에 대해 권한을 부여할 수 있기 때문에 ON 절에 `*.*` 이나 
> `<DB 명>.*` 을 사용한다.  
> 
> **테이블 권한**  
> ```sql
> GRANT SELECT, INSERT, UPDATE, DELETE ON *.* TO 'user'@'localhost';
> GRANT SELECT, INSERT, UPDATE, DELETE ON employees.* TO 'user'@'localhost';
> GRANT SELECT, INSERT, UPDATE, DELETE ON employees.department TO 'user'@'localhost';
> ```
> 테이블 권한은 첫 번째 예제와 같이 서버의 모든 DB 에 대해 권한을 부여하는 것도 가능하며, 두 번째 예제와 같이 특정 DB 의 오브젝트에 대해서만 권한을 부여하는 것도 가능하다.  
> 그리고 세 번째 예제와 같이 특정 DB 의 특정 테이블에 대해서만 권한을 부여하는 것도 가능하다.  
>
> **칼럼 단위 권한**  
> 칼럼 단위의 권한은 잘 사용하지 않으며 칼럼 단위 권한이 하나라도 설정되면 나머지 모든 테이블의 모든 칼럼에 대해서도 권한 체크를 하기 때문에 
> 칼럼 하나에 대해서만 권한을 설정하더라도 전체적인 성능에 영향을 미칠 수 있다.  
> 
> **권한 쿼리 예시**  
> 1.특정 DB 에 대한 CRUD 권한 부여: `GRANT SELECT, INSERT, UPDATE, DELETE ON <DB 명>.* TO '<username>'@'<host>';`  
> 1-1.시스템 권한을 포함한 모든 권한 부여: `GRANT ALL PRIVILEGES ON *.* TO '<username>'@'<host>';`  
> 
> 2.권한 변경 후 적용: `FLUSH PRIVILEGES`  
> 
> 3.계정별 권한 조회: `SHOW GRANTS FOR '<username>'@'<host>';`      
> 참고. 계정 조회: `select user, host from mysql.user;`  
>
> 4.모든 권한 삭제: `REVOKE ALL ON <DB 명>.<테이블 명> FROM '<username>'@'<host>';`  
> 4-1.업데이트 권한 삭제: `REVOKE UPDATE ON <DB 명>.<테이블 명> FROM '<username>'@'<host>';`

### 역할(Role)
> MySQL 8.0 부터 권한들을 묶은 역할을 생성할 수 있다.  
> 
> **역할 생성**  
> ```sql
> CREATE ROLE <role 이름>, <role 이름>, ...;
> ```
> 역할 생성 시 뒤에 `%'<hostname>'` 붙여서 역할을 생성할 수도 있는데 사실 역할의 정체는 로그인 정보가 없는 계정이기 때문이다.  
> 역할에 로그인 정보를 주어서 로그인이 가능해지는 경우 hostname 이 의미를 가지며 단순히 역할로 사용할 때는 hostname 의 의미가 없다.  
> 그래서 역할 생성 시 hostname 을 주지 않으며, hostname 을 주지 않으면 hostname 이 '%' 로 자동으로 붙여진다.   
>
> **역할에 권한 부여**  
> ```sql
> GRANT <권한> ON <DB 명>.<Table 명> TO <역할 명>;
> 
> # 예시
> GRANT SELECT ON employees.* TO role_emp_read;
> GRANT INSERT, UPDATE, DELETE ON employees.* TO role_emp_write;
> ```
> 
> **회원에 역할 부여**  
> ```sql
> GRANT <역할 명> TO '<username>'@'<hostname>';
> 
> # 예시 1: reader 와 writer 역할 권한을 부여
> GRANT role_application_writer, role_application_reader TO 'app_writer'@'%';
> 
> # 예시 2: reader 역할 권한만 부여
> GRANT role_application_reader TO 'app_reader'@'%';
> ```
>
> **역할 목록 확인**  
> 역할은 회원과 동일하게 취급되기 때문에 mysql.user 테이블에 존재한다.  
> 다만 회원과 다른 점은 역할은 대부분 host 가 '%' 로 되어있으며(회원처럼 % 가 아닌 다른 host 를 설정할 수 있긴 하다.) 역할을 통해서는 로그인할 수 없기 때문에
> authentication_string 에는 빈 값이 들어가있다.(null 은 아니다.)
> ```sql
> SELECT user AS role_name
> FROM mysql.user
> WHERE host = '%'
> AND LENGTH(authentication_string);
> 
> # 혹은 역할 계정임을 나타내는 'role_' prefix 를 사용자가 임의로 넣어서 역할 계정을 관리하는 경우
> SELECT user AS role_name
> FROM mysql.user
> WHERE user like 'role_%' 
> ```
> MySQL 에서는 역할과 계정을 구분하지 않는다. 그래서 역할을 계정으로 변경시켜서 계정으로 사용할 수도 있다.  
> 역할과 계정을 구분하기 위해서는 사용자가 역할의 이름 앞에 'role_' 과 같이 prefix 혹은 뒤에 '_role' 과 같이 postfix 를 사용하여 해당 계정이
> 역할 계정임을 나타내는 것을 권장한다.
> 
> **역할 활성화**  
> 역할은 부여(GRANT) 만 한다고 역할의 권한 기능을 바로 사용할 수 없다.  
> 역할에 부여된 권한을 사용자가 사용하기 위해서는 연결된 세션(connection) 에서 `SET ROLE '<역할 명>'` 을 통해서 역할을 활성화 해주어야한다.  
> 연결된 세션 마다 해주어야하기 때문에 불편하고 수동적이다.  
> 이를 연결 시 자동으로 역할을 활성화해주는 옵션을 셋팅하면 해결 가능하다.  
> ```sql 
> SET GLOBAL activate_all_roles_on_login = ON;
> ```   
> 
> **회원에 부여된 역할 제거**  
> ```sql
> REVOKE <역할 명> from '<username>'@'<hostname>';
> 
> # 예시
> REVOKE role_app_writer from 'app_writer'@'%'; 
> ```

### 회원 및 역할 생성 및 배정
> 계정 생성 시 특정 IP 는 회사 사무실 IP 혹은 AWS 사용 시 Bastion host IP 로 설정하는 것이 좋다.  
> 하지만 Bastion host 의 IP 로 설정 시에는 Bastion host 의 IP 가 변하지 않는 경우에만 하도록 주의하자.  
> 
> **개발자**  
> ```sql
> # 계정 생성
> CREATE USER '<개발자 아이디>'@'<특정 IP>' identified by '<password>';
> 
> # 역할 생성
> CREATE ROLE ROLE_DEV;
> 
> # 권한 부여: 특정 DB 는 조회만 허용, information_schema 는 조회만 허용
> GRANT SELECT ON <db 명>.* TO ROLE_DEV; 
> 
> # 역할 부여
> GRANT ROLE_DEV TO '<개발자 아이디>'@'%';
> ```
> 
> **DBA**  
> ```sql
> # 계정 생성
> CREATE USER '<DB 관리자 아이디>'@'%' identified by '<password>';
> 
> # 역할 생성
> CREATE ROLE ROLE_DB_ADMIN;
> 
> # 권한 부여: 모든 권한 허용
> GRANT ALL ON *.* TO ROLE_DB_ADMIN; 
> 
> # 역할 부여
> GRANT ROLE_DB_ADMIN TO '<DB 관리자 아이디>'@'%';
> ``` 
> 
> **애플리케이션**  
> ```sql
> # 계정 생성
> CREATE USER '<애플리케이션 아이디>'@'%' identified by '<password>';
> 
> # 역할 생성
> CREATE ROLE ROLE_APPLICATION;
>
> # 권한 부여: 특정 DB 의 CRUD 허용
> GRANT SELECT, INSERT, UPDATE, DELETE ON <db 명>.* TO ROLE_APPLICATION; 
> 
> # 역할 부여
> GRANT ROLE_APPLICATION TO '<애플리케이션 아이디>'@'%';
> ```  

---

## 엔진
### 엔진과 스토리지 엔진
> MySQL 엔진 + 스토리지 엔진을 합쳐서 MySQL 서버라고 부른다.  
> MySQL 엔진의 종류는 1개이지만 스토리지 엔진의 종류는 여러가지이며 대표적으로 InnoDB 스토리지 엔진과 MyISAM 스토리지 엔진이 있다.  
> 스토리지 엔진은 테이블 생성 시에 지정을 할 수 있으며 각 테이블마다 다른 스토리지 엔진을 사용할 수 있다.  
> 스토리지 엔진은 데이터를 읽고 쓰는 기능만 처리하며 그 외의 작업은 모두 MySQL 엔진에서 처리된다.  
> MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오가나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.  

### 백그라운드 스레드
> 백그라운드 스레드 중 가장 중요한 것은 `로그 스레드`와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 `쓰기 스레드(write thread)`이다.  
> InnoDB 의 경우 MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있다.  
> `innodb_write_io_threads` 와 `innodb_read_io_threads` 시스템 변수로 스레드의 개수를 설정한다.  
> 읽기 작업의 경우 주로 클라이언트 스레드(connection 마다 존재)에서 처리되기 때문에 많은 스레드 갯수가 필요하지 않지만 
> 쓰기 작업의 경우 내장 디스크를 사용할 때는 2~4 정도를 설정하는 것이 좋다.   
> 
> 읽기 및 쓰기 스레드 갯수 확인 쿼리  
> ```sql
> show global variables where variable_name like 'innodb_%_io_threads';
> ```

### 실행 엔진과 핸들러
> **실행 엔진**  
> 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.  
> 
> **핸들러(스토리지 엔진)**  
> MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.  

### 쿼리 캐시
> MySQL 8.0 버전으로 오면서 쿼리 캐시의 기능이 사라졌다.  

### InnoDB 스토리지 엔진 아키텍처
> InnoDB 는 MySQL 에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.    
> InnoDB 의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 
> 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.

### MVCC
> MVCC 의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다. InnoDB 는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.
> 여기서 멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.    
> 하나의 트랜잭션에서 Update 쿼리가 실행되면 InnoDB 버퍼 풀에 있는 레코드가 갱신되며 레코드의 업데이트 이전의 내용은 언두 로그에 기록된다.  
> 다른 트랜잭션에서 동일 레코드를 조회 시에 READ_UNCOMMITTED 이면 InnoDB 버퍼 풀에 있는 레코드를 읽게 되며 그 외에 
> READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE 의 경우에는 언두 로그에 기록된 레코드를 읽게 된다.  
> 
> *InnoDB 버퍼풀: 조회로 인하여 레코드를 메모리(RAM)에 일정 기간 상주시키고 있는데 이 메모리 공간을 버퍼풀이라고 한다.   

### 자동 데드락 감지
> InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.  
> InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서
> 그중 하나를 강제 종료한다. 
> 
> InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수 도 있는데, `innodb_table_locks`
> 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다. 특별한 이유가 없다면 `innodb_table_locks`
> 시스템 변수를 활성화하자.  
> `show variables where variable_name = 'innodb_table_locks'`
> 
> 일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않는다.
> 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다. 
> 이런 문제점을 해결하기 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공하며, OFF 설정 시 데드락 감지 스레드는 더이상 작동되지 않게 된다.
> 데드락 감지 스레드가 작동하지 않으면 InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황이 발생해도 누군가가 중재를
> 하지 않기 때문에 무한정 대기하게 될 것이다. 
> 하지만 `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 이런 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다.  
> `innodb_lock_wait_timeout` 은 초 단위로 설정할 수 있으며, `innodb_deadlock_detect` 를 OFF 로 설정해서 비활성화하는 경우라면 `innodb_lock_wait_timeout`을
> 기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.  
> 
> ```sql
> # 데드락 감지 스레드 활성화 상태
> show variables where variable_name = 'innodb_deadlock_detect';
> 
> # 락 대기 타임아웃(초 단위) 설정 조회
> show variables where variable_name = 'innodb_lock_wait_timeout';
> ```

### InnoDB 버퍼풀
> InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.  
> MySQL 5.7 버전 이후로는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선됐다.  
> 처음으로 MySQL 서버를 준비한다면 다음과 같은 방법으로 InnoDB 버퍼 풀 설정을 찾아가는 방법을 권장한다.  
> 전체 메모리 공간이 8GB 미만이라면 50% 정도인 4GB 만 InnoDB 버퍼 풀로 설정하고 나머지 메모리 공간은 MySQL 서버와 운영체제, 
> 그리고 다른 프로그램이 사용할 수 있는 공간으로 확보해주는 것이 좋다.  
> 전제 메모리 공간이 8GB 이상이라면 InnoDB 버퍼 풀의 크기를 전체 메모리의 50% 에서 시작해서 조금씩 올려가면서 최적점을 찾는다.  
>
> 버퍼 풀 크기 확인 쿼리: `show variables where variable_name = 'innodb_buffer_pool_size';`
> 
> InnoDB 버퍼 풀의 크기는 동적으로 변경할 수 있지만 버퍼 풀의 변경은 크리티컬한 변경이므로 가능하면 MySQL 서버가 한가한 시점을 골라서 진행하는 것이 좋다.  
> 또한 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 가능하면 버퍼 풀의 크기를 줄이는 
> 작업은 하지 않도록 주의하자.  
> 
> InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경합을 줄이기 위해
> 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선됐다.  
> `innodb_buffer_pool_instances` 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있는데, 각 버퍼 풀을 버퍼 풀 인스턴스라고 표현한다.  
> 기본적으로 버퍼 풀 인스턴스의 개수는 8개로 초기화되지만 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만이면 버퍼풀 인스턴스는 1개만 생성된다.  
> 버퍼 풀로 할당할 수 있는 메모리 공간이 40GB 이하 수준이라면 기본 값인 8을 유지하고, 메모리가 크다면 버퍼 풀 인스턴스당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋다.  
> 
> 버퍼풀 인스턴스 확인 쿼리: `show variables where variable_name = 'innodb_buffer_pool_instances';`

### 버퍼 풀과 리두 로그
> 버퍼 풀은 서버의 성능 향상을 위한 데이터 캐시 및 쓰기가 필요한 레코드들을 모아 한꺼번에 디스크에 적용하는 쓰기 버퍼링 두가지를 제공한다.  
> InnoDB 의 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지(Dirty Page)도 가지고 있다.  
> 
> InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
> 리두 로그의 공간이 모두 차게되면 체크포인트 이벤트가 발생한다.  
> 
> 리두 로그 파일 사이즈 확인 쿼리  
> ```sql
> show variables where variable_name = 'innodb_redo_log_capacity';
> ```
> Mysql 공식문서를 보면 리두 로그 파일을 버퍼풀 크기만큼 크게 만들라고 한다.  
> redo 로그 파일을 버퍼 풀만큼 크게 만듭니다.  
> InnoDB가 redo 로그 파일을 가득 채운 경우, 버퍼 풀의 수정된 내용을 체크포인트에서 디스크에 기록해야 합니다.  
> redo 로그 파일이 작을 경우 불필요한 디스크 쓰기가 많이 발생합니다.  
> 과거에는 대규모 redo 로그 파일이 복구 시간을 오래 끌었지만 이제는 복구 속도가 훨씬 빨라져 대용량 redo 로그 파일을 안심하고 사용할 수 있습니다.  
> 
> 로그 버퍼는 디스크의 리두 로그파일에 기록될 데이터를 보유하는 메모리 영역이다.  
> 로그 버퍼의 크기는 innodb_log_buffer_size 변수로 설정할수 있다. (일반적으로 4MB ~ 16MB 가 좋은 크기라고 한다)  
> 로그 버퍼크기를 크게 조정하면 트랜잭션을 커밋 하기 전에 디스크에 로그를 쓰지않아도 큰 트랜잭션을 실행할수 있다.  
> 많은 행을 업데이트, 삽입, 삭제하는 트랜잭션이 있는 경우 로그버퍼를 크게조정하면 DISK I/O 가 절약된다.  
> ```sql
> show variables where variable_name = 'innodb_log_buffer_size';
> ```
> 
> `innodb_page_cleaners` 는 `innodb_buffer_pool_instances` 와 갯수를 맞춘다.  
> ```sql
> show variables where variable_name in ('innodb_page_cleaners', 'innodb_buffer_pool_instances');
> ```
> 
> `innodb_io_capacity`, `innodb_io_capacity_max` 는 InnoDB 버퍼풀이 디스크를 읽고 쓰는 경우 속도를 의미한다. 디스크 IOPS 속도이며,
> 적절한 값은 운영을 통해서 알아가야하며, 디폴트는 각각 200, 2000 이다.  
> ```sql
> show variables where variable_name in ('innodb_io_capacity', 'innodb_io_capacity_max');
> ```

### 참조사이트
> [Mysql Redo Log 란](https://dus815.tistory.com/entry/Mysql-Redo-Log-란)

### 어댑티브 해시 인덱스
> 어댑티브 해시 인덱스는 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이며,
> `innodb_adaptive_hash_index` 시스템 변수를 이용해서 활성화하거나 비활성화 할 수 있다.  
> 
> 어댑티브 해시 인덱스는 해시 기능을 통해서 B-Tree 인덱싱보다 좋은 성능 및 CPU 사용률을 줄여준다.   
> 
> 어댑티브 해시 인덱스는 InnoDB 버퍼풀(RAM 메모리)에 있는 데이터에 대해서만 인덱스를 생성하기 때문에 디스크 읽기가 많은 경우 등 상황에서 효용이 없을 수 있다.  
> MySQL 서버의 기본 설정은 어댑티브 해시 인덱스를 사용하도록 되어 있다.  
> 
> 어댑티브 해시 인덱스는 테이블의 삭제 및 스키마 수정 작업에 많은 영향을 미친다. 테이블의 삭제/변경 따라 인덱스의 삭제/변경 해야하기 때문이다.  
> 따라서 어댑티브 해시 인덱스가 Online DDL 을 사용하는 경우에 상당한 시간을 소요시킬 수 있다.  
> 
> ```sql
> SHOW ENGINE INNODB STATUS \G
> ...
> -------------------------------------
> INSERT BUFFER AND ADAPTIVE HASH INDEX
> -------------------------------------
> ...
> 1.03 hash searches/s, 2.64 non-hash searches/s
> ```
> 위의 쿼리로 조회 쿼리 사용시 어댑티브 해시 인덱스 사용률을 알 수 있다. 여기서는 총 3.67(1.03 + 2.64) 중 1.03 번의 해시 인덱스 사용으로
> 28% 의 사용률을 알 수 있다.  
> 이 서버의 CPU 사용량이 100% 라는 가정하에 28% 의 인덱스 사용률을 보였다면 사용하는 것이 좋지만, CPU 사용량이 높지 않은 상태에서 28% 라면
> 어댑티브 해시 인덱스를 비활성화하는 편이 나을 수 있다.  

### 기타 엔진
> Memory 스토리지 엔진은 테이블 수준의 락만 지원하기 때문에 동시 처리에서 InnoDB 엔진보다 성능이 좋지 않다.  
> Memory 스토리지 엔진과 MyISAM 스토리지 엔진의 경우 하위 호환성을 위해서 유지하는 것으로 보이며 InnoDB 와 비교해서 장점이 없다.  
> 그래서 차후 버전에서는 제거될 것으로 예상된다.  

### 제너럴 쿼리 로그 파일
> MySQL 서버에서 실행된 쿼리 목록을 저장한 로그 파일  
> 로그 파일 위치 확인
> ```sql
> show variables where variable_name = 'general_log_file';
> ```

### 슬로우 쿼리 로그
> `long_query_time` 시스템 변수에 설정한 초 이상의 시간이 걸린 쿼리를 저장하는 로그  
> 반드시 쿼리가 정상적으로 실행이 완료되어야 기록된다.  
>
> ```sql
> # 슬로우 쿼리 임계 시간 확인(초)
> show variables where variable_name = 'long_query_time';
>
> # 슬로우 쿼리 로그 파일 위치 확인
> show variables where variable_name = 'slow_query_log_file';
> ```

---

## Lock
### 메타데이터(metadata) 락
> 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 자동으로 획득되는 잠금이다. 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니다.

### ALGORITHM=INSTANT
> 기존 테이블의 구조 변경 작업 중에는 메타데이터 락 및 테이블 락이 걸려서 해당 테이블의 구조의 변경이 완료되기 전까지는 데이터가 INSERT 되지않았다.   
> 하지만 테이블 변경 쿼리 뒤에 `,ALGORITHM=INSTANT` 를 붙이면 메타데이터 락 및 테이블 락 없이 테이블 구조의 변경이 진행되기 때문에 데이터 조회 및 INSERT 에 문제가 없다.    
> 
> 현재 ALGORITHM=INSTANT 이 지원하는 기능은 다음과 같다.  
> 1.테이블 RENAME  
> 2.칼럼의 Default 값 설정/삭제/변경  
> 3.ENUM, SET 타입에 값 추가  
> 4.신규 칼럼 추가(Default 값이 있어도 관계 없음)
>
> **참조사이트**  
> [MySQL 8.0.12 Online DDL 방식 추가 (INSTANT Algorithm)](https://m.blog.naver.com/seuis398/221375024684)  
> [MySQL/MariaDB, 테이블 락 최소화하여 변경하기](https://jsonobject.tistory.com/515)  

### 레코드 락(Record lock)
> 레코드 자체만을 잠그는 것을 레코드 락이라고 한다.  
> InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 특징이 있다.  
> InnoDB 에서는 보조 인덱스를 이용한 변경 작업은 넥스트 키락 또는 갭 락을 사용한다.  
> 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭 락에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.  
> 
> UPDATE 시 조건에 사용되는 컬럼 중에 인덱스가 걸린 컬럼이 있으면 해당 컬럼의 값에 해당하는 레코드는 모두 락이 걸린다.  
> 예를 들어 `update employee set hire_date=now() where first_name='jujin' and last_name='robert';` 쿼리문을 가정하자.  
> first_name 칼럼에는 인덱스가 걸려있으며 first_name='jujin' 에 해당하는 레코드가 30개라고 가정하자.  
> last_name 칼럼에는 인덱스가 걸려있지 않다.  
> first_name='jujin' and last_name='robert' 에 해당하는 레코드는 1개라고 가정하자.  
> 그럼 위의 update 쿼리를 실행한 경우 first_name='jujin' and last_name='robert' 에 해당하는 레코드는 1개이기 때문에 해당 레코드만 락이 걸릴거 같다.  
> 하지만 first_name 에만 인덱스가 걸려있기 때문에 MySQL 은 first_name='jujin' 에 해당하는 레코드 30개를 모두 레코드 락을 건다.   
> 그리고 update 쿼리를 실행이 완료되면 30개의 레코드 락이 해제된다.
> 만약 employee 테이블에 인덱스가 하나도 없다면 테이블을 풀스캔하면서 update 작업을 하는데, 이 과정에서 테이블에 있는 모든 레코드를 잠그게 된다.  
> 이것이 MySQL 의 방식이며, MySQL 의 InnoDB 에서 인덱스 설계가 중요한 이유 또한 이것이다.  
> 왠만하면 겹치는 것이 없는 클러스터드 인덱스(PK) 를 사용하여 업데이트 하는 것이 Best 일 듯 싶다.  
> 혹은 보조 인덱스를 사용하더라도 대체키가 될 만한 컬럼에 유니크 인덱스를 걸은 후 해당 칼럼을 사용해서 update 하는 것이 차선일 듯 싶다.  

### 갭 락(Gap lock)
> 갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.  
> 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다.  
> 갭 락은 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.  

### 넥스트 키 락(Next key lock)
> InnoDB 의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
> 그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.  
> 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭락을 줄이는 것이 좋다.  
> 
> 바이너리 로그 포맷 확인 쿼리: `SELECT @@binlog_format;`  
> 바이너리 로그 포맷 설정: my.cnf 
> ```
> [mysqld]
> ...
> binlog_format=2   # binlog 포맷(0: MIXED, 1:STATEMENT, 2:ROW)
> ```

### 자동 증가 락(Auto increment lock)
> MySQL 에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 라는 칼럼 속성을 제공한다.  
> AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져아한다.  
> 이를 위해 InnoDB 스토리지 엔진에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다.  
> AUTO_INCREMENT 락은 INSERT, REPLACE 와 같이 새로운 레코드를 저장하는 쿼리에서만 동작한다.  
> AUTO_INCREMENT 락은 트랜잭션과 관계없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.  
> 
> MySQL 5.1 이상부터는 `innodb_autoinc_lock_mode` 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.  
> 자동 증가 락 모드 확인 쿼리: `show variables where variable_name = 'innodb_autoinc_lock_mode';`  
> 
> **innodb_autoinc_lock_mode=0**  
> MySQL 5.0 과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락을 사용한다.  
> 
> **innodb_autoinc_lock_mode=1**  
> 단순히 한 건 또는 여러 건의 레코드를 INSERT 하는 SQL 중 MySQL 서버가 INSERT 되는 레코드 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 
> 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤택스)를 이용해 처리한다.  
> 개선된 래치는 자동 증가 락과 달리 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제된다.  
> 하지만 INSERT ... SELECT 와 같이 MySQL 서버가 쿼리를 실행하기 전에 건수를 예측할 수 없을 때는 MySQL 5.0 에서와 같이 자동 증가 락을 사용한다.  
> 
> **innodb_autoinc_lock_mode=2**  
> 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤택스)를 사용한다. 이 설정에서는 하나의 INSERT 문장으로 INSERT 되는 레코드라고 하더라도 연속된 자동 증가
> 값을 보장하지는 않는다.   
> 이 설정 모드에서는 INSERT ... SELECT 와 같은 대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT 를 수행할 수 있으므로 동시 처리 성능이
> 높아진다. 하지만 이 설정에서 작동하는 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장한다.  
> STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수도 있기 때문에 STATEMENT 포맷의 바이너리
> 로그를 사용한다면 innodb_autoinc_lock_mode=1 로 변경해서 사용할 것을 권장한다.  
> innodb_autoinc_lock_mode=2 는 바이너리 로그 포맷이 ROW 인 경우에만 사용을 권장한다.   

### 트랜잭션 격리 수준
> READ COMMITTED 격리 수준에서는 트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 외부에서 실행되는 SELECT 문장의 차이가 별로 없다.  
> 하지만 REPEATABLE READ 격리 수준에서는 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다. 즉, START TRANSACTION 명령으로 
> 트랜잭션을 시작한 상태에서 온종일 동일한 쿼리를 반복해서 실행해봐도 동일한 결과만 보게 된다.  

### MySQL 의 기본 트랜잭션 격리 수준
> REPEATABLE READ 는 MySQL 의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 
> 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.  
> InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다. 
> 이러한 변경 방식을 MVCC 라고 한다.  
>
> 한 사용자가 BEGIN 으로 트랜잭션을 시작하고 장시간 트랜잭션을 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수도 있다. 
> 이렇게 언두에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.  
>
> InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 PHANTOM READ 가 발생하지 않는다.  

---

## 데이터 압축
### 테이블 압축 개요
> 증가하는 데이터로 인해서 서버의 저장공간이 부족 혹은 추가적인 HDD의 증설을 줄이려는 방법으로 데이터 수정(UPDATE)이 발생하지 않는 로그 테이블에 
> 적용하여 조회 속도 향상 및 저장 공간을 줄일 수 있는 기법. 
> 테이블 압축은 테이블 데이터를 압축해서 보관함으로 파일 I/O를 감소시키는 것이 가장 큰 목적입니다. (반대로 압축을 하게 되면 수정 시에는 속도가 느림)  

### 장단점
> 장점은 일반 테이블 보다 파일 크기를 줄일 수 있고, 데이터 조회 속도는 큰 차이가 없습니다.   
> 단점은 DML 수행 속도가 느려지며, 과거 데이터에 대한 관리 방법이 필요하다고 판단 합니다.  

### 내 의견
> 현재 내 의견은 로그의 경우에는 RDB 에 저장하는 것이 비용적으로 좋지 않다고 생각된다. 파일 혹은 NoSQL 고려가 필요할 듯 하다.  
> 로그가 아닌 수정이 발생하지 않는 테이블의 경우도 역시 마찬가지로 NoSQL 을 고려하는 것이 좋아보인다.  

### 참조사이트
> [[Admin] MariaDB/MySQL InnoDB 테이블 압축(Compression)](https://estenpark.tistory.com/377)

---

## 데이터 암호화
### MySQL 서버의 데이터 암호화
> MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다.
> 그래서 MySQL 서버에서 데이터 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다. 즉, MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만
> 데이터의 암호화 및 복호화 과정이 실행되는 것이다.  
> 
> 데이터 암호화 기능이 활성화돼 있다고 하더라도 MySQL 내부와 사용자 입장에서는 아무런 차이가 없기 때문에 이러한 암호화 방식을 가리켜 TDE(Transparent Data Encryption)
> 이라고 한다.
> 
> 암호화된 테이블과 그렇지 않은 테이블의 디스크 읽고 쓰기에 걸리는 평균 시간을 비교해보면 다음과 같다.  
> 암호화된 테이블의 경우 읽기는 3배에서 5배 정도 느리며, 쓰기의 경우 5배에서 6배 정도 느린 것을 확인할 수 있다.  
> 물론 밀리초 단위이므로 수치가 워낙 낮은 편이어서 크게 체감되지는 않을 수도 있다.  
> 테이블의 크기가 206GB 임에도 읽기 속도가 평균 1.44 ms 이고 쓰기 속도가 평균 0.12 ms 가 나오기 때문에 일반적인 상황에서는 암호화로 인한 성능 저하를
> 크게 느끼기 힘들듯 싶다.  

### 암호화 테이블 생성
> TDE 를 이용하는 테이블은 다음과 같이 생성할 수 있다. 
> ```sql
> create table tab_encryted (
>   id bigint,
>   data varchar(100),
>   primary key(id)
> ) ENCRYPTION = 'Y';
> ```
> 
> 테이블을 생성할 때 마다 `ENCRYPTION = 'Y'` 를 설정하면 실수로 암호화 적용을 잊어버릴 수도 있다.  
> MySQL 서버의 모든 테이블에 대해 암호화를 적용하고자 한다면 `default_table_encryption` 시스템 변수를 ON 으로 설정하면
> `ENCRYPTION = 'Y'` 를 붙이지 않아도 암호화된 테이블로 생성된다.  
> default_table_encryption 확인 쿼리: `show variables where variable_name = 'default_table_encryption'`  

### 애플리케이션 레벨의 암호화와 차이점
> 애플리케이션 레벨에서 암호화를 하여 암호화한 데이터를 MySQL 에 INSERT 하게하는 방식이 존재한다.  
> 애플리케이션 레벨의 암호화를 사용하는 경우 동일 값을 찾는 이퀄 연산으로 데이터 조회가 가능하지만 범위 값을 사용하는 연산은 사용이 불가능하다.  
> MySQL 서버의 TDE 기능으로 암호화한다면 실행 중인 MySQL 서버에 로그인할 수 있다면 모든 데이터를 평문으로 확인할 수 있다.  

---

## 인덱스
### 디스크 읽기 방식
> 최근에는 하드 디스크가 아닌 SSD 드라이브가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이다.  
> 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O 를 줄이느냐가 관건일 때가 상당히 많다.  
> 
> 한번에 많은 데이터를 읽는 순차 I/O 에서는 디스크의 헤더를 움직일 필요가 없기 때문에 HDD 와 SSD 의 속도 차이는 크지 않다.  
> 하지만 SSD 의 장점은 기존 하드 디스크 대비 랜덤 I/O 가 훨씬 빠르다는 점이다.  
> 데이터베이스 서버에서는 순차 I/O 작업 보다는 랜덤 I/O 작업이 주 이기 때문에 SSD 를 사용하는 것이 성능에 훨씬 유리하다.  
> 
> 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 `랜덤 I/O`를 사용하며, 풀 테이블 스캔은 `순차 I/O`를 사용한다.  
> 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.   
> 이러한 형태는 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

### 인덱스란?
> DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로
> 삼아 인덱스를 만들어 두는 것이다.  
> 인덱스의 주요 특징 중 하나는 정렬이다. DBMS의 인덱스는 칼럼의 값을 주어진 순서대로 미리 정렬해서 보관한다.  
> 
> DBMS 의 인덱스는 데이터가 저장될 때 마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.  
> 그래서 인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 문장의 처리가 느려진다. 하지만 이미 정렬된 인덱스를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리할 수 있다.  
> (내 생각) 그렇기 때문에 인덱스는 기본적으로 SELECT 문장에서 where 절에 들어갈 칼럼을 설정하게 되며, 인덱스로 지정되는 칼럼은 왠만하면 UPDATE 가 없는 칼럼인 대체키 칼럼을 지정하면
> 조금 더 성능을 높힐 수 있을 듯 하다.  
> 단지 where 조건절에서 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.  
 
### B-Tree 인덱스
> B-Tree 인덱스에서 B 는 Binary 가 아닌 `Balanced` 이다.  
> 대부분 인덱스는 거의 B-Tree 를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.  
> 
> **구조 및 특성**  
> B-Tree 는 최상위에 루트 노드(Root node) 가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.  
> 트리 구조의 가장 하위에 있는 노드를 리프 노드(Leaf node)라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 브랜치 노드(Branch node)라고 한다.  
> 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.  
> 
> **B-Tree 인덱스 키 추가 및 삭제**  
> 일반적으로 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.  
> 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.  
> 
> B-Tree 인덱스 키는 인덱스가 걸린 칼럼의 값을 의미한다.  
> 인덱스의 값으로 MyISAM 인덱스의 경우 인덱스가 레코드의 물리적인 주소를 가지는 반면 InnoDB 인덱스의 경우에는 인덱스의 값으로 논리적인 주소(프라이머리 키 인덱스)를 가진다고 볼 수 있다.
> (InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에)  
> 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.  
> 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
> 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스(따로 지정하는 인덱스) 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree
> 를 다시 한번 검색해야 한다.  
> InnoDB 의 경우 인덱스 키에 대해 변경 및 삭제에 대한 작업을 체인지 버퍼를 통해서 지연 처리를 하여 성능 최적화로 동작한다.   
> 
> B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호(<, >) 비교 조건에서도 인덱스를 활용할 수 있지만, 
> 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키 값에 변형이 가해진 후 
> 비교되는 경우에는 절대 B-Tree 의 빠른 검색을 사용할 수 없다는 것이다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한
> 결과로 정렬한다거나 검색하는 작업은 B-Tree 의 장점을 이용할 수 없으므로 주의해야 한다.  
> 
> InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭 락)이 검색을 수행한 인덱스를 잠근 후
> 테이블의 레코드를 잠그는 방식으로 구현돼 있다. 따라서 UPDATE 나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.
> 심지어 테이블의 모든 레코드를 잠글 수도 있다.  
> InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.  

### B-Tree 인덱스 사용에 영향을 미치는 요소
> InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.  
> InnoDB 의 B-Tree 는 이진 트리처럼 자식 노드가 2개가 아닌, 설정에 따라 여러 개의 자식 노드를 갖는다.  
> MySQL 5.7 버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 `innodb_page_size` 시스템 변수를 이용해 4KB ~ 64KB 사이의 값을 선택할 수 있지만 
> 기본값은 16KB다.  
> 하나의 인덱스 페이지(16KB)에 몇 개의 키를 저장할 수 있을까?  
> 키 값의 크기가 16바이트라고 가정하고 자식 노드 주소가 12바이트라고 가정해보면 16x1024/(16+12) = 585개 저장할 수 있다.  
> 키 값의 크기가 32바이트로 늘어났다고 가정하면 16x1024/(32+12) = 372개 저장할 수 있다.  
> SELECT 쿼리를 통해 레코드를 500개를 읽어야 한다면 전자는 인덱스 페이지 한번으로 해결될 수도 있지만, 후자는 최소한 2번 이상 디스크로부터 읽어야 한다.
> 결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.
> 
> **B-Tree 깊이**  
> B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.  
> 인덱스의 B-Tree 깊이가 3인 경우 최대 몇 개의 키 값을 가질 수 있는지 한 번 비교해 보자.  
> 키 값이 16바이트인 경우에는 최대 2억(585 * 585 * 585)개 정도의 키 값을 담을 수 있다.  
> 키 값이 32바이트인 경우에는 최대 5천만(372 * 372 * 372)개로 줄어든다.  
> B-Tree 의 깊이는 MySQL 에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다. 인덱스 키 값의 크기가 커지면 디스크 읽기가 더 많이
> 필요하게 된다.  
> 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋으며, 아무리 대용량 데이터베이스라도 B-Tree 의 깊이가 5단계 이상까지 깊어지는 경우는 흔치 않다.  
> 
> **선택도(기수성)**  
> 인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.  
> 전체 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수가 10개라면 기수성은 10이다.  
> 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.  
> 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.  
> 하지만 인덱스가 항상 검색에만 사용되는 것이 아니므로 여러가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.  
> 선택도가 좋지 않다고 하더라도 정렬이나 그룹핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.  
> 
> **읽어야 하는 레코드의 건수**  
> 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.  
> 일박적인 DBMS 의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4배에서 5배정도 비용이 더 많이 드는
> 작업으로 예측한다. 즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20%에서 25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서
> 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.  
> 예를 들어 전체 100만 건의 레코드 가운데 50만건을 읽어야 하는 작업은 인덱스의 손익 분기점인 20~25%보다 훨씬 크기 때문에 MySQL 옵티마이저는 인덱스를
> 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리할 것이다.  
> 참고로 예시 상황에서 강제로 인덱스를 사용하도록 쿼리 힌트를 추가해도 성능상 얻을 수 있는 이점은 없다.  
 
### B-Tree 인덱스를 통한 데이터 읽기
> **인덱스 레인지 스캔**  
> 여기서는 인덱스를 통해 레코드를 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 모두 묶어서 "인덱스 레인지 스캔"이라고 표현하였다. 
> (물론 두 경우는 각각 다른 이름을 가진다.)  
> 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현하다.  
> 인덱스 레인지 스캔 시 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다. 이는 별도로 정렬 과정이
> 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 그렇게 된다.
> 인덱스를 스캔을 통해서 읽어야할 레코드들이 정해지면 각 레코드들을 가져오기 위한 랜덤 I/O 가 각각 발생하게 된다.  
> 그래서 인덱스를 통해 읽어야 할 데이터 레코드가 전체 레코드의 20~25%를 넘어가면 인덱스를 통한 읽기(랜덤 I/O)보다 테이블 데이터를 직접 읽는 것이 더 효율적인
> 처리 방식이 된다.(순차 I/O)  
> 
> **인덱스 풀 스캔**  
> 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다. 대표적으로 쿼리의 조건절에 사용된 칼럼이
> 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. 예를 들어, 인덱스는 (A, B, C) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은
> B 칼럼이나 C 칼럼으로 검색하는 경우다.  
> 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다. 하지만 인덱스 칼럼 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면
> 절대 이 방식으로 처리되지 않는다.  
> 이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은
> 테이블 전체를 읽는 것보다는 적은 디스크 I/O 로 쿼리를 처리할 수 있다.
> 
> **인덱스 스킵 스캔**  
> 데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.  
> 인덱스를 통한 조회 시에 인덱스의 첫번째 칼럼을 기준으로 먼저 필터링하며 그 후 인덱스의 칼럼들을 기준으로 필터링한다.  
> 예를 들어 gender, birth_date 를 묶은 인덱스가 있다고 가정하면 where 조건에 gender 조건이 있어야만 해당 인덱스를 효율적으로 사용한다.  
> 만약 select 에 gender, birth_date 만 조회하고 where 조건에 birth_date 만 필터링한다면 인덱스 풀 스캔으로 조회한다.  
> MySQL 8.0 버전부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이
> 도입됐다.  
> 
> 인덱스 스킵 스캔은 MySQL 8.0 버전에 새로이 도입된 기능이어서 아직 다음과 같은 단점이 있다.  
> 1.where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함 - 위의 예시로 gender 의 경우 'M', 'F' 로 갯수가 2개 뿐이어서 
> 인덱스 스킵 스캔이 효율적으로 동작하였음. 만약 선행 칼럼의 유니크한 값의 개수가 많아지면 오히려 성능이 더 느려질 수 있음.  
> 
> 2.쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스): select 절에 gender, birth_date 로 인덱스로 잡힌 칼럼만 조회하는 경우여야만 함.
> 그렇지 않고 * 를 써서 row 의 모든 칼럼 데이터를 가져오게 되면 인덱스 스킵 스캔을 사용하지 않고 테이블 풀 스캔으로 조회하게 된다.  
>
> **다중 칼럼(Multi-column) 인덱스**  
> 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬된다. 즉, 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다.  
> 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되고 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다.  
> 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 그것을 아주 신중히 결정해야 한다.  
> 
> **B-Tree 인덱스의 정렬 및 스캔 방향**  
> 일반적인 상용 DBMS 에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다.  
> MySQL 8.0 버전부터는 다음과 같은 형태의 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.  
> ```sql
> CREATE INDEX ix_teamname_userscore ON employee (team_name ASC, user_name DESC);
> ```
> 인덱스는 기본적으로 정순 정렬로 만들어지고 정순 정렬 인덱스를 사용하여 인덱스 풀 스캔 사용 시 역순 정렬(DESC) 쿼리가 정순 정렬(ASC) 쿼리보다 28.9% 더 시간이 걸린다.
> 
> 일반적으로 인덱스를 order by ... DESC 하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요는 없다.  
> 하지만 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적이라고 볼 수 있다.  
> 
> **인덱스의 가용성**  
> B-Tree 인덱스의 특징은 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬돼 있다는 것이다. 여기서 왼쪽이란 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의
> 칼럼에 대해서도 함께 적용된다.  
> 예를 들어 first_name 칼럼에 인덱스가 걸려있고 다음의 쿼리를 실행하면,
> ```sql
> select * from employee where first_name like '%mer';
> ```
> 이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수는 없다. 그 이유는 first_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서
> 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값('%mer')에는 왼쪽 부분이 고정되지 않았기 때문이다.  
> 
> 기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미한다.  
> 작업 범위 결정 조건: 비교 레코드 범위를 줄여주는 것  
> 1.NOT-EQUAL 로 비교된 경우: `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`    
> 2.LIKE '%??' 앞부분이 아닌 뒷부분 일치 형태로 문자열 패턴이 비교된 경우    
> 3.스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우: `WHERE SUBSTRING(column, 1, 1) = 'x'`    
> 4.NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우: `WHERE column = deterministic_function()`  
> 5.데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우): `where char_column = 10`  
> 6.문자열 데이터 타입의 콜레이션이 다른 경우: `where utf8_bin_char_column = euckr_bin_char_column`  
> 
> 다른 일반적인 DBMS 에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL 에서는 NULL 값도 인덱스에 저장된다. 다음과 같은 where 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.
> ```sql
> ... where column is null ...
> ```

### R-Tree 인덱스
> MySQL 의 공간 인덱스(Spatial Index) 는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다. 
> 기본적인 내부 매커니즘은 B-Tree 와 흡사하다. B-Tree 는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값이다.  
> GIS 와 GPS 에 기반한 위치 기반 서비스를 구현하는 방법으로 MySQL 의 공간 인덱스를 사용하여 간단하게 구현할 수 있다.  
> R-Tree 는 일반적으로는 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다.  

### 전문 검색 인덱스
> B-Tree 인덱스의 경우 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능하다.  
> 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색에는 InnoDB 나 MyISAM 스토리지 엔진에서 제공하는
> 일반적인 용도의 B-Tree 인덱스를 사용할 수 없다.  
> 
> **어근 분석**  
> 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다. MySQL 서버에서는 오픈소스 형태소 분석 라이브러리인 MeCab 을 플러그인 형태로 사용할 수 있게 
> 지원한다. (MeCab 은 일본어를 위한 형태소 분석 프로그램이며, 서구권 언어를 위한 형태소 분석기는 MongoDB 에서 사용되는 Snowball 이라는 오픈소스가 있다.)  
> MeCab 을 위한 형태소 분석은 매우 전문적인 검색 알고리즘이어서 만족할 만한 결과를 내기 위해서는 많은 노력과 시간을 필요로한다. 
> 전문적인 검색 엔진을 고려하는 것이 아니라면 범용적으로 적용하기는 쉽지 않다.
> 
> **n-gram 알고리즘**  
> n-gram 알고리즘은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이다.   
> 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.  
> 형태소 분석보다는 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없는 반면, 만들어진 인덱스의 크기는 상당히 큰 편이다.    
> n-gram 에서 n 은 인덱싱할 키워드의 최소 글자 수를 의미하는데, 일반적으로는 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram(또는 Bi-gram) 방식이 많이 사용된다.  
> 
> **전문 검색 인덱스의 가용성**  
> 전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 한다.  
> * 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...) 을 사용  
> * 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유  
>
> 예시) doc_body 칼럼에 전문 검색 인덱스 추가한 예시 테이블 생성한다.  
> ```sql
> CREATE TABLE tb_test (
>   doc_id INT,
>   doc_body TEXT,
>   PRIMARY KEY (doc_id),
>   FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
> ) ENGIN=InnoDB;
> ```
> 다음 쿼리를 사용하면 전문 검색 인덱스를 사용하지 않고 테이블을 풀 스캔하게 됨.  
> ```sql
> select * from tb_test where doc_body like '%애플%';
> ```
> 전문 검색 인덱스를 사용하려면 반드시 다음과 같이 `MATCH (...) AGAINST (...)` 구문으로 조회 쿼리를 작성해야 하며,
> 전문 검색 인덱스를 구성하는 칼럼들은 MATCH 절의 괄호 안에 모두 명시돼야 한다.  
> ```sql
> select * from tb_test 
>   where MATCH(doc_body) AGAINST ('애플' IN BOOLEAN MODE); 
> ```

### 멀티 밸류 인덱스
> 멀티 밸류 인덱스는 하나의 데이터 레코드(row)가 여러 개의 키 값을 가질 수 있는 형태의 인덱스이다.  
> 최근 RDBMS 들이 JSON 데이터 타입을 지원하기 시작하면서 JSON 의 배열 타입의 필드에 저장된 원소(Element)들에 대한 인덱스 요건이 발생한 것이다.  
> ```sql
> CREATE TABLE user (
>   id BIGINT AUTO_INCREMENT PRIMARY KEY,
>   first_name VARCHAR(10),
>   last_name VARCHAR(10),
>   credit_info JSON,
>   INDEX mx_creditscores (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY))
> );
> ```
> 멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안되고, 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다. 
> * MEMBER OF()
> * JSON_CONTAINS()
> * JSON_OVERLAPS()
>
> ```sql
> EXPLAIN SELECT * FROM user WHERE 360 MEMBER OF (credit_info->'$.credit_scores');
> ```

### 클러스터링 인덱스
> MySQL 에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다.  
> 클러스터링 인덱스는 테이블의 프라이머리 키(Primary key)에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을
> 클러스터링 인덱스라고 표현한다. 여기서 중요한 것은 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는 것이다. 프라이머리 키 값으로 클러스터링된
> 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 한다.   
> 
> 일반적으로 InnoDB 와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 
> 프라이머리 키의 변경이 상대적으로 느리다.  
> 
> 테이블 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 "클러스터링 인덱스" 또는 "클러스터링 테이블" 이라고 한다.
> 
> 세컨더리 인덱스(사용자 지정 인덱스)를 위한 일반 B-Tree 의 리프 노트와는 달리 클러스터링 인덱스의 리프 노드에는 레코드(row)의 모든 칼럼이 같이 저장되어 있다.  
> 
> InnoDB 테이블에서 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성하자.  
> 
> **장점**  
> 1.프라이머리 키로 검색할 때 처리 성능이 매우 빠름. 특히 프라이머리 키를 범위 검색하는 경우 매우 빠름.  
> 2.테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음.  
> 
> **단점**  
> 1.테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐.    
> 2.세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림.    
> 3.INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림.  
> 4.프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림.  
>
> **클러스터링 테이블 사용 시 주의사항**  
> 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함한다. 그래서 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.  
> 일반적으로 테이블에 인덱스가 4~5개 정도 생성된다는 것을 고려하면 다음 비교가 가능하디.  
> 프라이머리 키 크기: 10바이트, 레코드 당 증가하는 인덱스 크기: 10바이트 * 인덱스 5개 = 50바이트, 100만건 저장시 인덱스 크기: 50바이트 * 100만 = 47MB  
> 프라이머리 키 크기: 50바이트, 레코드 당 증가하는 인덱스 크기: 50바이트 * 인덱스 5개 = 250바이트, 100만건 저장시 인덱스 크기: 250바이트 * 100만 = 238MB  
> 
> MySQL 의 클러스터링 인덱스를 이용한 성능 최적화 관점에서 프라이머리 키는 가능하면 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성한다.  
> 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때가 가끔 있다. 하지만 프라이머리 키의 크기가 길어도 
> 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋다. 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을
> 추가하고, 이를 프라이머리 키로 설정하면 된다. 이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate key)라고 한다.  
> 
> 하지만 애플리케이션 및 비즈니스의 변경이 일어나서 업무적인 칼럼의 PK 를 변경해야하는 상황이 올 수도 있기 때문에 비즈니스적으로 생각하면 인조 식별자를 추천하기도 한다.   
> 
> **UUID 프라이머리 키에 대한 사견**  
> UUIDv4 를 프라이머리 키로 사용 시 INSERT 에 오버헤드가 발생하게 된다.  
> 그리고 관계 설정을 위해서는 프라이머리 키를 통해서 관계를 설정하게됨으로 그로 인해 외래키의 크기도 기존 BIGINT(8) 에서 BINARY(16) 으로 2배 더 커지게 된다.  
> 또한 클러스터링 인덱스(PK)를 통한 조회 성능에서 이점을 보는 것 보다 INSERT/UPDATE/DELETE 에서 UUIDv4 를 사용하여 빈번한 순서 정렬로 인한 성능저하의 단점을 더 크게보는 시각도 있다.  
> 위의 이유들로 UUIDv4 보다는 UUIDv1(순서보장) 혹은 AUTO-INCREMENT 칼럼을 사용하는 것이 더 나아보인다.  
> 
> **참조사이트**  
> [UUID와 increment PK는 언제 사용해야할까?](https://americanopeople.tistory.com/378)  
> [RDB에서 UUID를 사용할 때 고민해볼점](https://velog.io/@devkingsejong/RDB에서-UUID를-무작정-사용하지-말아야-하는-이유)    
> [[MySQL] UUID의 개념과 성능 개선 결과](https://chanos.tistory.com/entry/MySQL-UUID를-효율적으로-활용하기-위한-노력과-한계)    
> [UUID vs Auto Increment 중 PK 선택하기](https://stir.tistory.com/294)  

### 유니크 인덱스
> 유니크는 사실 인덱스라기보다는 제약 조건에 가깝다고 불 수 있다. 말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데,
> MySQL 에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다. 유니크 인덱스에서 NULL 도 저장될 수 있는데, NULL 은 특정 값이 아니므로 2개 이상 저장될 수 있다. 
> MySQL 에서 프라이머리 키는 기본적으로 NULL 을 허용하지 않는 유니크 속성이 자동으로 부여된다. 
> InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로 유니크 인덱스와는 근본적으로 다르다.  
> 
> 유니크 인덱스와 일반 인덱스의 성능 차이는 없다. 유니크한 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU 에서 칼럼값을 비교하는
> 작업이기 때문에 이는 성능상 영향이 거의 없다고 볼 수 있다.  
> 
> MySQL 에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다. 
> 또한 InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만,
> 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다. 이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더
> 느리게 작동한다.  
> 
> 유니크 인덱스를 성능이 좋을 것이라고 생각해서 불필요한데 유니크로 인덱스를 걸 필요는 없다.  
> 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 이미 특정 칼럼에 대한 인덱스가 있는데 유니크 인덱스로 중복해서 또 만들 필요는 없다.  

### 외래키
> MySQL 에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다. 
> 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.  
> 
> **자식 테이블의 변경이 대기하는 경우**  
> 자식 테이블의 외래 키 칼럼의 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요한데, 자식 테이블에서 외래키 값을 변경하려는 경우
> 다른 트랜젝션에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 된다. 
> 이것이 InnoDB 외래키 관리의 첫 번째 특징에 해당된다.  
> 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장(위의 예제)이 발생하지 않는다. 이것이 InnoDB 의 외래키의 두 번째 특징에 해당한다.  

---

## 옵티마이저와 힌트
### 개요
> **쿼리 실행 절차**  
> MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.
> 1.사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.  
> 2.SQL 의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.  
> 3.두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
> 
> **비용 기반 최적화(Cost-based optimizer, CBO)**  
> 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해
> 실행 계획별 비용을 산출한다. 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.  

### 기본 데이터 처리
> MySQL 은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼(Sort buffer) 라고 한다.  
> 소트 버퍼는 세션(로컬) 메모리 영역에 해당한다. 즉, 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다. 커넥션이 많으면 많을수록,
> 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미한다.  
> 
> **정렬 알고리즘**  
> 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 싱글 패스(Single-pass)와 투 패스(Two-pass) 2가지
> 정렬 모드로 나눌 수 있다.   
> 싱글 패스(Single-pass)는 레코드 전체(order by 절에 있는 칼럼뿐만 아니라 select 절에 오는 칼럼 모두)를 전부 읽어서 소트 버퍼에 담고 정렬을 수행한다.
> 그리고 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨준다.  
> 투 패스(Two-pass)는 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 
> select 할 칼럼을 가져오는 정렬 방식으로 테이블을 두 번 읽어야하는 불합리함이 있다.  
> 
> 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용한다. 하지만 다음의 경우, MySQL 서버는 싱글 패스 정렬 방식을 사용하지 못하고 투 패스 정렬 방식을 사용한다.  
> * 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때  
> * BLOB 이나 TEXT 타입의 칼럼이 select 대상에 포함할 때
> 
> select 쿼리에서 꼭 필요한 칼럼만 조회하지 않고, 모든 칼럼(select * ...)을 가져오도록 개발할 때가 많다. 하지만 이는 정렬 버퍼를 몇 배에서 몇십 배 까지
> 비효율적으로 사용할 가능성이 크다. select 쿼리에서 꼭 필요한 칼럼만 조회하도록 쿼리를 작성하는 것이 좋다고 권장하는 것은 바로 이런 이유 때문이다.  
> 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 쿼리에서도 영향을 미친다.  
> 
> **정렬 처리 방법**  
> 쿼리에 `ORDER BY`가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리 된다.  
> 1.인덱스를 사용한 정렬  
> 2.조인에서 드라이빙 테이블만 정렬  
> 3.조인에서 조인 결과를 임시 테이블로 저장 후 정렬  
> 
> **인덱스를 사용한 정렬**  
> 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY 에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY 의 순서대로
> 생성된 인덱스가 있어야 한다. 또한 WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY 는 같은 인덱스를 사용할 수 있어야 한다. 
> 그리고 B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.  
> 예시
> ```sql
> -- e.emp_no 에 인덱스가 있다고 가정한다.
> select * 
> from employee e, salaries s
> where s.emp_no = e.emp_no
>   and e.emp_no between 10002 and 10020
> order by e.emp_no;
> ```
> 위의 쿼리 예시에서 where 절에 `e.emp_no between 10002 and 10020` 조건으로 인하여 `order by e.emp_no` 가 없이도 e.emp_no 인덱스의 순서대로
> 정렬된 결과를 가져온다. 하지만 그렇다고 해서 order by 절을 지우는 것은 좋지 않은 판단이다.  
> order by 절을 넣었을 때 MySQL 서버가 별도로 정렬 작업을 한 번 더할까 봐 걱정할 수 있지만, MySQL 서버는 정렬을 인덱스로 처리할 수 있는 경우 부가적으로
> 불필요한 정렬 작업을 수행하지 않는다.  
> 또한 어떤 이유로 쿼리의 실행 계획이 조금 변경된다면 order by 가 명시되지 않은 쿼리는 결과를 기대했던 순서로 가져오지 못해서 애플리케이션의 버그로 연결될 수도 있다.
> 그렇기 때문에 order by 절이 필요한 경우 빼지 않고 명시적으로 적어주는 것이 좋다.  
> 
> **조인의 드라이빙 테이블만 정렬**  
> ```sql
> select * 
> from employee e, salary s 
> where s.emp_no = e.emp_no
>   and e.emp_no between 10002 and 10010
> order by e.last_name;
> ```
> 위의 쿼리에서 order by 의 e.last_name 이 조인의 드라이빙 테이블인 employee 의 칼럼임으로 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고,
> 그 결과와 salary 테이블을 조인한다.  
> 과정은 다음과 같다.  
> 1.인덱스를 이용해 `e.emp_no between 10002 and 10010` 조건을 만족하는 9건을 검색  
> 2.검색 결과를 last_name 칼럼으로 정렬을 수행(File sort)  
> 3.정렬된 결과를 순서대로 읽으면서 salary 테이블과 조인을 수행해 86건의 최종 결과를 가져옴.  
> 
> **임시 테이블을 이용한 정렬**  
> 쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 select 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 하지만 2개 이상의 테이블을 조인해서 그 결과를
> 정렬해야 한다면 임시 테이블이 필요할 수도 있다.  
> 이 방법은 정렬의 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.  
> ```sql
> select * 
> from employee e, salary s 
> where s.emp_no = e.emp_no
>   and e.emp_no between 10002 and 10010
> order by s.salary;
> ```
> 이번 쿼리에서는 order by 절의 정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블(salary)에 있는 칼럼이다.  
> 즉, 정렬이 수행되기 전에 salary 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수 밖에 없다.  
> explain 을 통해 위의 쿼리의 실행 계획을 보면 Extra 칼럼에 `Using temporary; Useing filesort` 라는 코멘트가 표시된다. 
> 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.  
> 
> **정렬 처리 방법의 성능 비교**  
> 주로 웹 서비스용 쿼리에서는 order by 와 함께 limit 이 거의 필수로 사용되는 경향이 있다. 일반적으로 limit 은 테이블이나 처리 결과의 일부만 가져오기 때문에
> MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다. 그런데 order by 나 group by 같은 작업은 where 조건을 만족하는 레코드를 limit 건수 만큼만 가져와서는
> 처리할 수 없다. 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 비로소 limit 으로 건수를 제한할 수 있다.  
> where 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 order by 나 group by 때문에 쿼리가 느려지는 경우가 자주 발생한다.  
> 
> **스트리밍 방식**  
> 스트리밍 방식은 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다.  
> 스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해준다.  
> 또한 스트리밍 방식으로 처리되는 쿼리에서 limit 처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다.  
> 
> **버퍼링 방식**  
> order by 나 group by 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. 우선 where 조건에 일치하는 모든 레코드를 가져온 후, 
> 정렬하거나 그루핑해서 차례대로 보내야 하기 때문인다.  
> MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다.  
> 버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 한다.  
> 그래서 버퍼링 방식으로 처리되는 쿼리는 limit 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않는다.  
> 
> JDBC 라이브러리를 이용해 "select * from bigtable" 같은 쿼리를 실행하면 MySQL 서버는 레코드를 읽자마자 클라이언트로 그 결과를 전달한다. 
> 하지만 JDBC 는 MySQL 서버로부터 받는 레코드를 일단 내부 버퍼에 모두 담아둔다. 그리고 마지막 레코드가 전달될 때까지 기다렸다가 모든 결과를 전달받으면
> 그때서야 비로소 클라이언트의 애플리케이션에 반환한다. 즉 MySQL 서버는 스트리밍 방식으로 처리해서 반환하지만 클라이언트의 JDBC 라이브러리가 버퍼링하는 것이다.  
> 
> JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 이 방식이 전체 처리(Throughput) 시간이 짧고 MySQL 서버와의 통신 횟수가 적어 자원 소모가 줄어들기 때문이다.  
> 하지만 JDBC 의 버퍼링 처리 방식은 기본 작동 방식이며, 아주 대량의 데이터를 가져와야 할 때는 MySQL 서버와 JDBC 간의 전송 방식을 스트리밍 방식으로 변경할 수 있다.  
>
> 어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다. 가능하다면 인덱스를 사용한 정렬로 유도하고,
> 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.  
> 
> **group by 처리**  
> group by 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다. 인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 
> 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다. 그리고 인덱스를 사용하지 못하는 쿼리에서 group by 작업은 임시 테이블을 사용한다.  
> 
> 인덱스 스캔을 이용하는 group by(타이트 인덱스 스캔)  
> order by 의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 group by 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서
> 그룹핑 작업을 수행하고 그 결과로 조인을 처리한다.  
> group by 가 인덱스를 사용해서 처리된다 하더라도 그룹 함수(Aggregation function) 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.  
> group by 가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.  
> 
> 루스 인덱스 스캔을 이용하는 group by  
> 루스(Loose) 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하는데, 옵티마아저가 루스 인덱스 스캔을 사용할 때는 실행 계획의
> Extra 칼럼에 "Using index for group-by" 코멘트가 표시된다.  
> 
> ```sql
> explain 
> select emp_no
> from salary
> where from_date = '1985-03-01'
> group by emp_no;
> ```
> salary 테이블의 인덱스는 (emp_no, from_date) 로 생성돼 있으므로 위의 쿼리 문장에서 where 조건은 인덱스 레인지 스캔 접근 방식으로 이용할 수 없는 쿼리이다.
> 하지만 이 쿼리의 실행 계획은 인덱스 레인지 스캔(range type)을 이용했으며, Extra 칼럼의 메시지를 보면 group by 처리까지 인덱스를 사용했다는 것을 알 수 있다.  
> 
> 임시 테이블을 사용하는 group by  
> group by 의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.
> 임시 테이블을 사용하는 group by 쿼리에 explain 를 붙여 실행하면 실행 계획에서 Extra 칼럼에 "Using temporary" 메시지가 표시된다.  
> 
> MySQL 5.7 버전까지는 group by 가 사용되면 자동으로 그루핑 칼럼을 기준으로 정렬이 수행됐는데, 정렬이 필요치 않은 경우라면 "order by null" 을 추가로
> 사용할 것을 권장했다. 불필요한 추가 정렬 작업을 수행하지 않으므로 크진 않지만 성능 향상을 볼 수 있었기 때문이다.  
> 하지만 MySQL 8.0 버전 부터는 group by 를 사용하더라도 묵시적인 정렬이 수행되지 않기 때문에 정렬된 결과가 필요치 않은 경우 굳이 "order by null" 구문을 
> 추가하지 않아도 된다.  
> 
> **Distinct 처리**  
> 집합 함수(MIN, MAX, COUNT 등)와 같이 distinct 가 사용되는 쿼리의 실행 계획에서 distinct 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.  
> 하지만 실행 계획의 Extra 칼럼에는 "Using temporary" 메시지가 출력되지 않는다.  
> 
> distinct 를 사용할 때 자주 실수하는 것이 있다. distinct 는 select 하는 레코드(튜플)를 유니크하게 select 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.  
> 즉, 다음 쿼리에서 select 하는 결과는 first_name 만 유니크한 것을 가져오는 것이 아니라 (first_name, last_name) 조합 전체가 유니크한 레코드를 가져오는 것이다.  
> ```sql
> select distinct first_name, last_name from employees;
> ```
> 가끔 distinct 를 다음과 같이 함수처럼 사용하는 사람도 있는데 실제로 MySQL 서버는 distinct 의 괄호를 그냥 의미 없이 사용된 괄호로 해석하고 제거해 버린다.  
> 
> ```sql
> explain
> select count(distinct s.salary)
> from employee e, salary s
> where e.emp_no = s.emp_no
> and e.emp_no between 10001 and 10100;
> ```
> 위의 쿼리처럼 집합 함수 내에서 distinct 키워드가 사용될 수 있는데, 이경우에는 일반적으로 `select distinct` 와 다른 형태로 해석된다.  
> 집합 함수가 없는 select 쿼리에서 distinct 는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져온다.  
> 하지만 집합 함수 내에서 사용된 distinct 는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.    
> distinct 처리를 위해 인덱스를 이용할 수 없는 경우에는 임시 테이블이 필요하다.  
> 인덱스된 칼럼에 distinct 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.  
> 
> **내부 임시 테이블 활용**  
> MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용한다.  
> MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다.  
> 사용자가 생성한 임시 테이블(CREATE TEMPORARY TABLE) 과는 달리 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.  
> 
> 임시 테이블이 최대한 사용 가능한 메모리 공간의 크기는 `temptable_max_ram` 시스템 변수로 제어할 수 있는데, 기본값은 1GB로 설정돼 있다.
> 임시 테이블의 크기가 1GB 보다 커지는 경우 MySQL 서버는 메모리의 임시 테이블을 디스크로 기록하게 된다.

### 고급 최적화
> **인덱스 확장(use_index_extensions)**  
> ```sql
> create table dept_emp (
>     emp_no int not null,
>     dept_no char(4) not null,
>     from_date date not null,
>     to_date date not null,
>     primary key (dept_no, emp_no),
>     key ix_fromdate (from_date)
> ) engine=InnoDB;
> ```
> 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키를 포함한다(complex key 인 경우 칼럼 선언 순서대로 포함한다).  
> 그래서 최정족으로 ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동할 수 있게 된다.  
> 예전 MySQL 버전에서는 세컨더리 인덱스의 마지막에 자동 추가되는 프라이머리 키를 제대로 활용하지 못했지만 MySQL 서버가 업그레이드되면서
> 옵티마이저는 ix_fromdate 인덱스의 마지막에 프라이머리 키(dept_no, emp_no) 칼럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선됐다.  
> 세컨더리 인덱스의 마지막에 프라이머리 키 칼럼이 있기 때문에 조회 조건에 프라이머리 키가 아닌 세컨더리 인덱스의 equal 조회 시에 결과 집합은 프라이머리 키로 정렬되어 있다.  
> 
> **테이블 풀-아웃(Table Pull-out)**  
> in (subquery) 를 사용할 경우 옵티마이저가 in subquery 를 조인 형태로 쿼리를 변경해서 실행해준다.  
> MySQL 에서는 최대한 서브쿼리를 조인으로 풀어서 사용해라 라는 튜닝 가이드가 많은데, Table pullout 최적화는 이 가이드를 그대로 실행하는 것이다. 
> 그래서 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.  
> 
> **퍼스트 매치(FirstMatch)**  
> in (subquery) 를 사용할 경우 exist 쿼리로 치환이 가능한 쿼리에 대해서 옵티마이저가 exist 쿼리 방식으로 처리해주는 방식이다.  
> 처리 시 실행 계획의 Extra 칼럼에 "FirstMatch(table-N)" 문구가 표시된다.  
> 
> **중복 제거(Duplicate Weed-out)**  
> in (subquery) 를 일반적인 inner join 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.  
> in (subquery) 를 inner join + group by 로 바꿔서 중복을 제거한다.  
> 실행 계획의 Extra 칼럼에 "Duplicate Weedout" 이란 문구가 별도로 표시되거나 하진 않는다. 하지만 Extra 칼럼에 "Start temporary" 와 "End temporary" 
> 문구가 별도로 표기된 것을 확인할 수 있다.  
> 
> **파생 테이블 머지(derived_merge)**  
> MySQL 서버에서는 from 절에 사용된 서브쿼리를 파생 테이블(Derived Table) 이라고 부른다.  
> MySQL 서버는 내부적으로 임시 테이블을 생성하고 파생 테이블의 레코드를 임시 테이블로 INSERT 한다. 그리고 다시 임시 테이블을 읽으므로 MySQL 서버는 
> 레코드를 복사하고 읽는 오버헤드가 더 추가된다. 내부적으로 생성되는 임시 테이블은 처음에는 메모리에 생성되지만, 임시 테이블에 저장될 레코드 건수가 많아지면 결국
> 디스크로 다시 기록돼야 한다. 그래서 임시 테이블이 메모리에 상주할 만큼 크기가 작다면 성능에 큰 영향을 미치지 않겠지만 레코드가 많아진다면 임시 테이블로
> 레코드를 복사하고 읽는 오버헤드로 인해 쿼리의 성능은 많이 느려질 것이다.  
> 
> MySQL 5.7 버전부터는 이렇게 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입됐는데,
> `derived_merge` 최적화 옵션은 이러한 임시 테이블 최적화를 활성화할지 여부를 결정한다.  
> 
> **해시 조인(hash_join)**  
> MySQL 8.0.18 버전부터 해시 조인이 추가로 지원된다.  
> 해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다. 해시 조인 쿼리는 최고 스루풋(Best Throughput) 전략에 
> 적합하다.  
> 네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만 첫 번째 레코드를 찾는 것은 상대적으로 훨씬 빠르다는 것을 알 수 있다. 
> 최고 응답 속도(Best Response-time) 전략에 적합하다.  
> 일반적인 웹 서비스는 온라인 트랜잭션(OLTP) 서비스이기 때문에 스루풋도 중요하지만 응답 속도가 더 중요하다. 그리고 분석과 같은 서비스는 사용자의 응답 시간보다는
> 전체적으로 처리 소요 시간이 중요하기 때문에 응답 속도보다는 전체 스루풋이 중요하다.  
> MySQL 서버는 범용 RDBMS 이며, 여기서 범용이라 함은 온라인 트랜잭션 처리를 위한 데이터베이스 서버를 지칭하는 것이다. 아마도 대용량 데이터 분석을 위해서
> MySQL 서버를 사용하지는 않을 것이다. 이 관점에서 본다면 MySQL 서버가 응답 속도와 스루풋 중 응답 속도에 더 집중해서 최적화할 것임이 명확하다.  
> 그렇기 때문에 네스티드 루프조인이 성능이 나오지 않을 때만 차선책으로 해시조인을 사용하도록 설계되어있다. 
> 그러니 해시조인이 빠르다고 무작정 옵티마이저 힌트를 사용해 강제로 해시조인을 유도하는 것은 MySQL 설계 의도를 위반하는 행위라는 것을 유의하자! 
 
### 쿼리 힌트
> 여전히 MySQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지는 못한다. 그래서 서비스 개발자나 DBA 보다 MySQL 서버가 부족한 실행 계획을 수립할 때가
> 있을 수 있다. 이런 경우 쿼리 힌트를 사용할 수 있다.  
> 
> **인덱스 힌트**  
> 인덱스 힌트들은 모두 SQL 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다. 
> MySQL 5.6 버전부터 추가되기 시작한 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS 에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다. 
> 그래서 가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천한다. 

---

## 실행 계획
### 통계 정보
> 비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.  
> MySQL 5.6 버전부터는 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 개선됐다.
> 다음과 같은 이벤트가 발생하면 자동으로 통계 정보가 갱신된다.  
> * 테이블이 새로 오픈되는 경우  
> * 테이블의 레코드가 대량으로 변경되는 경우(테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSERT 나 DELETE 가 실행되는 경우)  
> * `ANALYZE TABLE` 명령이 실행되는 경우  
> * `SHOW TABLE STATUS` 명령이나 `SHOW INDEX FROM` 명령이 실행되는 경우  
> * InnoDB 모니터가 활성화되는 경우  
> * `innodb_stats_on_metadata` 시스템 설정이 ON 인 상태에서 `SHOW TABLE STATUS` 명령이 실행되는 경우  
> `innodb_stats_auto_recalc` 시스템 설정 변수의 값을 OFF 로 설정해서 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. (기본값은 ON 이다)  
> 
> 히스토그램(Histogram)  
> MySQL 8.0 버전부터 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 정보.  
> 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.  
> information_schema 데이터베이스의 `column_statistics` 테이블을 통해서 현재 히스토그램 정보를 조회할 수 있다.  
> 
> 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다. 하지만 히스토그램이 있으면 특정 범위의 데이터가
> 많고 적음을 식별할 수 있다.
> 
> 테이블을 조인하는 경우에 on 절 조건으로 데이터 조회 범위를 줄일 수 있는 칼럼에 대해 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를
> 줄일 수 있을지 옵티마이저가 더 정확히 판달할 수 있다.  
> 
> MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.  

### 실행 계획 확인
> **실행 계획 출력 포맷**  
> MySQL 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON 이나 TREE, 단순 테이블 형태로 선택할 수 있다.  
> 테이블 포맷 표시
> ```sql
> EXPLAIN
> select * from employee e 
> inner join ...
> where ...;
> ```
> 트리 포맷 표시 
> ```sql
> EXPLAIN FORMAT=TREE
> select * from employee e 
> inner join ...
> where ...;
> ```
> JSON 포맷 표시
> ```sql
> EXPLAIN FORMAT=JSON
> select * from employee e 
> inner join ...
> where ...;
> ```
> 
> **쿼리의 실행 시간 확인**  
> MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.  
> `EXPLAIN ANALYZE` 명령은 항상 결과를 TREE 포맷으로 보여주기 때문에 EXPLAIN 명령에 FORMAT 옵션을 사용할 수 없다.  
> `EXPLAIN ANALYZE` 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다.  
> 그래서 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 `EXPLAIN ANALYZE` 명령을 사용하면 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있다. 
> 쿼리의 실행 계획이 아주 나쁜 경우라면 EXPLAIN 명령으로 먼저 실행 계획만 확인해서 어느 정도 튜닝한 후 `EXPLAIN ANALYZE` 명령을 실행하는 것이 좋다.

### 실행 계획 분석
> EXPLAIN 명령의 기본 출력 포맷인 테이블 포맷에서 각 레코드는 쿼리 문장에서 사용된 테이블의 개수만큼 출력된다.  
> 실행 순서는 위에서 아래로 순서대로 표시된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록(id 칼럼의 값이 작을 수록) 쿼리의 바깥(Outer) 부분이거나
> 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록(id 칼럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당된다.  
> 
> **id 칼럼**  
> select 문장은 하나인데, 여러 개의 테이블이 조인되는 경우에는 id 값이 증가하지 않고 같은 id 값이 부여된다.  
> 반대로 쿼리 문장이 3개의 select 쿼리로 구성돼 있으면 실행 계획의 각 레코드가 각기 다른 id 값을 지닌다.  
> 여기서 주의해야할 점은 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.  
> 테이블 형태의 실행 계획에서는 테이블의 접근 순서가 조금 혼란스러울 수 있는데, EXPLAIN FORMAT=TREE 명령으로 확인해보면 순서를 더 정확히
> 알 수 있다.
> 
> **select_type 칼럼**  
> 각 단위 select 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼.  
> SIMPLE: UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 표시됨.  
> 
> PRIMARY: UNION 이나 서브쿼리를 가지는 select 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리는 PRIMARY 로 표시된다.  
> 
> SUBQUERY: FROM 절 이외에서 사용되는 서브쿼리일 때만 표시된다.  
> 
> DERIVED: FROM 절에서 사용된 서브쿼리일 때 표시되며, "파생 테이블" 이라는 단어는 DRRIVED 와 같은 의미로 이해한다.
> DERIVED 는 단위 selet 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. MySQL 5.6 버전부터는 옵티마이저 옵션에 따라
> 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.
> 
> DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽(Outer) select 쿼리에서 정의된 칼럼을 사용하는 경우 표시된다. DEPENDENT UNION 과 같이 
> DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브 쿼리)가 실행돼야 하므로 (DEPENDENT 가 없는) 일반 서브쿼리보다는 처리 속도가
> 느릴 때가 많다.  
> 
> MATERIALIZED: MySQL 5.6 버전부터 도입된 select_type 으로, 주로 from 절이나 in (subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.  
> 
> ```sql
> EXPLAIN
> select * from employees e 
> where e.emp_no in (select emp_no from salaries where salary between 100 and 1000);
> ```
> MySQL 5.6 버전까지는 employees 테이블을 읽어서 employees 테이블의 레코드마다 salaries 테이블을 읽는 서브쿼리가 실행되는 형태로 처리됐다. 
> 하지만 MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어
> 처리된다. DERIVED 와 비슷하다고 생각하면 될 것 같다.   
> 
> MySQL 8.0 버전부터는 FROM 절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다. 
> 하지만 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화된 쿼리를 작성하는 것은 중요하다.  
> 
> 쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 칼럼의 DERIVED 인 것이 있는지 확인해야 한다. 서브쿼리를 조인으로 해결할 수 있는 경우라면
> 서브쿼리보다는 조인을 사용할 것을 강력히 권장한다. 실제로 개발 시점에 쿼리를 작성할 때 많은 개발자들이 기능을 조금씩 단계적으로 추가해 가면서 쿼리를 개발한다.
> 이러한 개발 과정은 필요한 쿼리를 개발하기는 쉽지만 대부분 쿼리가 조인이 아니라 서브쿼리 형태로 작성된다는 단점이 있다. 물론 이런 절차로 개발하는 것이 생산성은
> 높겠지만 쿼리의 성능은 떨어진다. 쿼리를 서브쿼리 형태로 작성하는 것이 편하다면 반드시 마지막에는 서브쿼리를 조인으로 풀어서 고쳐 쓰는 습관을 들이자.
> 그러면 어느 순간 서브쿼리로 작성하는 단계 없이 바로 조인으로 복잡한 쿼리를 개발할 수 있을 것이다.  
> 
> **table 칼럼**  
> MySQL 서버의 실행 계획은 단위 select 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다. 
> table 칼럼에 <derived N> 또는 <union M,N> 과 같이 "<>"로 둘러싸인 이름이 명시되는 경우 해당 테이블은 임시 테이블을 의미한다.  
> select_type 이 MATERIALIZED 인 실행 계획에서는 `<subquery N>` 과 같은 값이 table 칼럼에 표시된다. 이는 서브쿼리의 결과를 구체화해서
> 임시 테이블로 만들었다는 의미이며, 실제로는 `<derived N>` 과 같은 방법으로 해석하면 된다.  
> 
> **type 칼럼**  
> 쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 나타낸다.
> 여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지, 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지 등을 의미한다.  
> type 칼럼으로 올 수 있는 값은 다음과 같다.  
> system (가장 최소 비용), const, eq_ref, ref, fulltext, ref_or_null, unique_subquery, index_subquery, range, index_merge, index, ALL(가장 최대 비용)  
> 
> const: 테이블 레코드의 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 where 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리
> 방식. 프라이머리 키나 유니크 키가 복합 키인 경우 일부만 사용한 경우 1건을 반환하더라도 ref 로 표시되며 키를 전부 사용해야 const 로 표시된다.  
> 옵티마이저에 의해서 최적화되는 시점에 type 이 const 인 select 에 대해서 해당 쿼리의 결과 값을 상수 값으로 치환하여 해당 쿼리를 참조하는 쿼리들이 
> 상수 값을 참조하도록 변환된다.  
> 
> eq_ref: 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 
> 
> ref: 동등(Equal) 조건으로 검색할 때 ref 접근 방법이 사용된다. ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 
> const 나 eq_ref 보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다. const, eq_ref, ref 는 
> 모두 매우 좋은 접근 방법으로 쿼리 튜닝 시 크게 신경쓰지 않고 넘어가도 무방하다.  
> 
> fulltext: MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다. MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다.   
> 
> ref_or_null: ref 접근 방법과 같은데, NULL 비교가 추가된 형태다. 접근 방법의 이름 그대로 ref 방식 또는 NULL 비교(IS NULL) 접근 방법을 의미한다. 
> 실제 업무에서 많이 활용되지 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해 두면 충분하다.  
> 
> unique_subquery: where 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다. unique_subquery 의 의미 그대로 서브쿼리에서
> 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.  
> 
> index_subquery: IN(subquery) 형태의 조건에서 subquery 의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음.  
> unique_subquery 의 경우는 IN(subquery) 형태의 조건에서 subquery 의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음.
> 
> range: 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때
> 사용된다. 얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 
> 볼수 있다.  
>
> index_merge: 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다. 하지만 이름에 index 가 들어가는 만큼의 
> 효율로 작동하는 것은 아니다. 
> 
> index: 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다. range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니라는 점을 잊지 말자.
> 
> ALL: 풀 테이블 스캔을 의미하는 접근 방법이다.풀 테이블 스캔은 지금까지 설명한 접근 방법으로는 처리할 수 없을 때 가장 마지막에 선택하는 가장 비효율적인 방법이다.  
> 데이터 웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리(억지로 인덱스를 사용하게 튜닝된 쿼리)보다 더 나은 접근 방법이기도 하다.
> 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니라는 점을 기억하자.
> 
> **주의**  
> Dev 나 Test 데이터로 Explain 시 테이블에 넣은 row 의 수가 너무 적어서 조인 테이블의 row 를 필터링해서 가져오는 것 보다 전체 row 를 모두 가져오는게
> 순차 읽기 때문에 성능이 더 좋다고 판단되면 MySQL 엔진이 최적화하여 type 에 ALL 나오기 때문에 해당 오해를 방지하기 위해서 
> 조인에서 필터링으로 인해 제외될 데이터를 10개 이상 더 삽입하는 것이 좋다.
> 
> **possible_keys 칼럼**  
> MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그 중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다. 
> 그런데 possible_keys 칼럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이다. 
> 즉, 말 그대로 "사용될법했던 인덱스의 목록"인 것이다.  
> 
> **key 칼럼**  
> key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다. 그러므로 쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지
> 확인하는 것이 중요하다. key 칼럼에 표시되는 값이 PRIMARY 인 경우에는 프라이머리 키를 사용한다는 의미이며, 그 이외의 값은 모두 테이블이나 인덱스를 생성할
> 때 부여했던 고유 이름이다.  
> MySQL 서버에서 프라이머리 키는 별도의 이름을 부여할 수 없으며, 기본적으로 PRIMARY 라는 이름을 가진다.  
> 
> **key_len 칼럼**  
> 실행 계획의 key_len 칼럼의 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 우리에게 알려준다. 
> 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.  
> 칼럼의 값은 바이트(byte) 단위의 값이다.  
> 때로는 key_len 필드의 값이 데이터 타입의 길이보다 조금 길게 표시되는 경우도 발생할 수 있다. 예를 들어 MySQL 에서 DATE 타입은 3바이트를 사용하는데 
> 실제로 where 조건에 인덱스가 DATE 타입인 칼럼을 비교했을 때 실행 계획에서 key_len 는 3이 나오지 않고 4가 나올 수 있는데 이는 해당 칼럼이
> NULL 일 수 있는 경우이다. MySQL 에서는 NOT NULL 이 아닌 칼럼에서는 칼럼의 값이 NULL 인지 아닌지를 저장하기 위해 1바이트를 추가로 더 사용한다.  
> 
> **ref 칼럼**  
> 접근방법이 ref 면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 칼럼의 값은 const 로 표시되고, 
> 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다. 
> 
> **rows 칼럼**  
> MySQL 실행 계획의 rows 칼럼 값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를
> 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다. 
> rows 칼럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다.  
> 
> **filtered 칼럼**  
> 쿼리 실행 시 인덱스가 걸린 칼럼과 인덱스가 걸리지 않은 칼럼에 대한 조건이 같이 존재할 때 인덱스로 먼저 검색을 실행 후 rows 칼럼값에 인덱스로 검색된
> 레코드 건수를 예측하여 표시 후 filtered 칼럼에는 rows 에 표시된 숫자 중 인덱스가 걸리지 않은 칼럼으로 필터링 후 남은 레코드의 비율이 얼마인지 표시한다.  
